import numpy as np
import random
from typing import Tuple, List

# Import the Knot class - assuming it's in the same directory for now
# If running as part of a package, adjust the import path accordingly
try:
    from .knot import Knot
except ImportError:
    from knot import Knot

def control_leashes(knot: Knot) -> Tuple[float, float]:
    """
    Adjusts node positions to move leash lengths towards the target length.

    Iterates through the leashes in a randomized order, adjusting the positions
    of adjacent nodes symmetrically to make their separation equal to
    knot.target_leash_length.

    As noted in the paper, a single application is not self-consistent, but
    repeated calls reduce leash length dispersion.

    Args:
        knot: The Knot object to modify.

    Returns:
        A tuple containing the minimum and maximum leash lengths found AFTER
        the adjustments in this pass.
    """
    n = knot.num_nodes
    target_length = knot.target_leash_length

    if n < 2 or target_length <= 0:
        # Cannot control leashes on single nodes or with non-positive target length
        current_leashes = knot.get_leash_lengths()
        if len(current_leashes) == 0:
            return (0.0, 0.0)
        return (np.min(current_leashes), np.max(current_leashes))

    # Random start and processing order (process each leash once)
    indices = list(range(n))
    random.shuffle(indices)

    # Small tolerance to avoid unnecessary adjustments due to floating point errors
    tolerance = 1e-9

    for i in indices:
        i_plus_1 = (i + 1) % n

        p_i = knot.nodes[i]
        p_i_plus_1 = knot.nodes[i_plus_1]

        vec = p_i_plus_1 - p_i
        current_dist = np.linalg.norm(vec)

        # Avoid division by zero and skip if already correct length
        if current_dist < tolerance or np.abs(current_dist - target_length) < tolerance:
            continue

        # Calculate the difference needed and the unit vector
        diff = target_length - current_dist
        unit_vec = vec / current_dist

        # Move each node by half the difference along the connecting line
        move_vec = unit_vec * (diff / 2.0)

        knot.nodes[i] -= move_vec
        knot.nodes[i_plus_1] += move_vec

    # Calculate and return the min/max leash lengths after adjustments
    final_leashes = knot.get_leash_lengths()
    return (np.min(final_leashes), np.max(final_leashes))

# New function
def find_neighbours(knot: Knot, skipped: int, epsilon: float) -> List[List[int]]:
    """
    Finds potentially overlapping neighbours for each node.

    A node k is considered a neighbour of node i if:
    1. Their index distance along the knot chain is greater than 'skipped'.
    2. Their spatial distance is less than knot.diameter + epsilon.

    Args:
        knot: The Knot object.
        skipped: The minimum index distance for nodes to be considered neighbours.
                 Hard spheres of nodes with index distance <= skipped do not repel.
        epsilon: A small extra distance buffer added to the diameter check.

    Returns:
        A list of lists, where neighbours_list[i] contains the indices of the
        neighbouring nodes for node i.
    """
    n = knot.num_nodes
    nodes = knot.nodes
    diameter = knot.diameter
    neighbours_list = [[] for _ in range(n)]
    check_distance_sq = (diameter + epsilon)**2 # Compare squared distances for efficiency

    if n < 2 or skipped < 0:
        return neighbours_list # Nothing to check

    for i in range(n):
        for k in range(i + 1, n): # Only need to check pairs once (i, k) where k > i
            # 1. Check index distance
            index_dist = min(k - i, n - (k - i))
            if index_dist <= skipped:
                continue

            # 2. Check spatial distance (use squared distance to avoid sqrt)
            vec = nodes[i] - nodes[k]
            spatial_dist_sq = np.dot(vec, vec) # Faster than np.linalg.norm(vec)**2

            if spatial_dist_sq < check_distance_sq:
                neighbours_list[i].append(k)
                neighbours_list[k].append(i) # Neighbours relationship is symmetric

    return neighbours_list

# New function
def remove_overlaps(knot: Knot, neighbours_list: List[List[int]], delta: float) -> Tuple[float, float]:
    """
    Detects and removes overlaps between neighbouring nodes.

    Iterates through nodes in a random order. For each node `i`, checks for overlaps
    with nodes `j` listed in `neighbours_list[i]`. If an overlap (distance < diameter)
    is found, the nodes `i` and `j` are moved symmetrically apart along the line
    connecting them until their distance is `knot.diameter + delta`.

    Args:
        knot: The Knot object to modify.
        neighbours_list: The list of neighbours for each node, typically generated by
                         `find_neighbours`.
        delta: An extra separation distance added when resolving overlaps (delta > 0
               is recommended in the paper to speed up tightening).

    Returns:
        A tuple containing the maximum overlap distance found BEFORE correction
        in this pass, and the average overlap distance (also before correction).
        Overlap distance is defined as `diameter - actual_distance` for overlapping pairs.
    """
    n = knot.num_nodes
    nodes = knot.nodes
    diameter = knot.diameter
    target_distance = diameter + delta
    tolerance = 1e-9 # For floating point comparisons

    if n < 2 or diameter <= 0:
        return (0.0, 0.0)

    # Random processing order
    indices = list(range(n))
    random.shuffle(indices)

    max_overlap = 0.0
    total_overlap = 0.0
    overlap_count = 0

    # Use a set to keep track of pairs we've already processed in this pass
    # to avoid double counting or conflicting adjustments (i,j) vs (j,i)
    processed_pairs = set()

    for i in indices:
        # Check neighbours identified by find_neighbours
        for j in neighbours_list[i]:
            # Ensure we process each pair only once (e.g., always process where i < j)
            # or use the processed_pairs set approach.
            # Let's use the set, which is safer if neighbours_list isn't strictly symmetric
            # or if adjustments affect subsequent checks within the same pass.
            pair = tuple(sorted((i, j)))
            if pair in processed_pairs:
                continue

            p_i = nodes[i]
            p_j = nodes[j]

            vec = p_j - p_i
            dist_sq = np.dot(vec, vec)

            # Check for overlap (dist < diameter -> dist_sq < diameter_sq)
            if dist_sq < diameter**2 - tolerance:
                dist = np.sqrt(dist_sq) # Need actual distance now

                # Avoid division by zero if nodes are coincident
                if dist < tolerance:
                    # Arbitrarily move along x-axis if coincident
                    unit_vec = np.array([1.0, 0.0, 0.0])
                    dist = 0.0
                else:
                    unit_vec = vec / dist

                # Record overlap before correcting
                overlap = diameter - dist
                if overlap > max_overlap:
                    max_overlap = overlap
                total_overlap += overlap
                overlap_count += 1

                # Calculate how much to move each node
                total_move_dist = target_distance - dist
                move_vec = unit_vec * (total_move_dist / 2.0)

                # Move nodes symmetrically
                nodes[i] -= move_vec
                nodes[j] += move_vec

                # Mark pair as processed for this pass
                processed_pairs.add(pair)

    average_overlap = total_overlap / overlap_count if overlap_count > 0 else 0.0
    return (max_overlap, average_overlap)

# New function
def shift_nodes(knot: Knot, shift_fraction: float) -> None:
    """
    Shifts nodes along the knot's path using linear interpolation.

    Each node P_i is moved either forward towards P_{i+1} or backward towards P_{i-1}
    by a specified fraction of the segment length. The direction (forward/backward)
    is chosen randomly for the entire operation in this implementation.

    The calculation is done based on original positions, and all nodes are updated
    simultaneously at the end.

    Args:
        knot: The Knot object to modify.
        shift_fraction: The fraction of the inter-node distance to shift by
                        (e.g., 0.1 for 10%). Should be > 0.
    """
    n = knot.num_nodes
    if n < 3 or shift_fraction <= 0:
        return # Cannot shift nodes on trivial paths or with no shift

    original_nodes = knot.nodes.copy()
    new_nodes = np.empty_like(original_nodes)

    # Choose a direction for this shift operation: +1 (forward) or -1 (backward)
    # Paper implies randomness ("left or right")
    direction = random.choice([-1, 1])

    for i in range(n):
        p_i = original_nodes[i]
        p_prev = original_nodes[(i - 1 + n) % n] # P_{i-1}
        p_next = original_nodes[(i + 1) % n] # P_{i+1}

        if direction == 1: # Shift forward (towards p_next)
            vec = p_next - p_i
            new_nodes[i] = p_i + shift_fraction * vec
        else: # direction == -1: Shift backward (towards p_prev)
            vec = p_prev - p_i
            new_nodes[i] = p_i + shift_fraction * vec

    # Update the knot nodes simultaneously
    knot.nodes = new_nodes

    # Note: This procedure changes node positions and likely the total length.
    # The main loop might need to call knot.update_length() afterwards if needed,
    # although the tightening step itself rescales L and l.

# --- Node Number Manipulation Functions (Sec 3.4) ---

def reduce_node_number(knot: Knot) -> None:
    """
    Reduces the number of nodes in the knot by half (approximately).

    Removes every second node from the knot chain.
    Updates the knot's node count, length, and target leash length.

    Args:
        knot: The Knot object to modify.
    """
    n = knot.num_nodes
    if n < 4: # Need at least 4 nodes to meaningfully reduce by half to >= 2
        print(f"Warning: Cannot reduce node number significantly for N={n}. Skipping.")
        return

    # Keep every second node
    new_nodes = knot.nodes[::2]

    knot.nodes = new_nodes
    knot.num_nodes = new_nodes.shape[0]

    # Recalculate length and target leash length based on new nodes
    knot.update_length()
    knot.target_leash_length = knot.length / knot.num_nodes if knot.num_nodes > 0 else 0

def double_node_number(knot: Knot) -> None:
    """
    Doubles the number of nodes in the knot.

    Inserts a new node at the midpoint between each existing adjacent pair of nodes.
    Updates the knot's node count, length, and target leash length.

    Args:
        knot: The Knot object to modify.
    """
    n = knot.num_nodes
    if n < 1:
        return # Cannot double zero nodes

    original_nodes = knot.nodes
    new_n = 2 * n
    new_nodes = np.empty((new_n, 3), dtype=original_nodes.dtype)

    for i in range(n):
        p_i = original_nodes[i]
        p_next = original_nodes[(i + 1) % n] # Wrap around for the last segment

        # Place original node
        new_nodes[2 * i] = p_i

        # Place interpolated node
        midpoint = p_i + 0.5 * (p_next - p_i)
        new_nodes[2 * i + 1] = midpoint

    knot.nodes = new_nodes
    knot.num_nodes = new_n

    # Recalculate length and target leash length
    # Length should ideally be very similar, but recalculate for consistency
    knot.update_length()
    knot.target_leash_length = knot.length / knot.num_nodes

def normalize_node_number(knot: Knot, target_density: float = 10.0) -> None:
    """
    Adjusts the number of nodes to a target value based on L/D.

    The target number of nodes is calculated as round(target_density * L / D),
    where L is the current knot length and D is the diameter.
    The knot is then resampled to have this target number of nodes, distributing
    them as evenly as possible along the knot's current path length.

    Args:
        knot: The Knot object to modify.
        target_density: The factor used in N_target = round(target_density * L / D).
                        Defaults to 10, as used in the paper.
    """
    if knot.diameter <= 0:
        print("Warning: Cannot normalize nodes with zero or negative diameter. Skipping.")
        return

    current_n = knot.num_nodes
    if current_n < 1:
        return # Cannot resample if no nodes exist

    # Calculate target number of nodes
    lambda_val = knot.length / knot.diameter
    target_n = max(3, round(target_density * lambda_val)) # Ensure at least 3 nodes

    if target_n == current_n:
        # print(f"Node count {current_n} already matches target {target_n}. Skipping normalization.")
        return # Already at target

    print(f"Normalizing node count from {current_n} to {target_n} (L/D={lambda_val:.2f})...")

    # Calculate cumulative lengths along the path
    original_nodes = knot.nodes
    segments = np.diff(original_nodes, axis=0, append=original_nodes[0:1])
    segment_lengths = np.linalg.norm(segments, axis=1)
    # Cumulative length array (0, seg1_len, seg1_len+seg2_len, ..., total_L)
    cumulative_lengths = np.zeros(current_n + 1)
    cumulative_lengths[1:] = np.cumsum(segment_lengths)
    total_length = cumulative_lengths[-1]

    if total_length <= 1e-9: # Avoid division by zero for zero-length knots
        print("Warning: Knot length is near zero. Cannot normalize nodes. Skipping.")
        knot.nodes = np.tile(original_nodes[0], (target_n, 1))
        knot.num_nodes = target_n
        knot.length = 0.0
        knot.target_leash_length = 0.0
        return

    # Define the desired arc lengths for the new nodes
    target_arc_lengths = np.linspace(0, total_length, target_n, endpoint=False)

    # Interpolate new node positions
    new_nodes = np.empty((target_n, 3), dtype=original_nodes.dtype)
    current_segment_index = 0
    for i, target_l in enumerate(target_arc_lengths):
        # Find which segment the target arc length falls into
        while cumulative_lengths[current_segment_index + 1] < target_l:
            current_segment_index += 1

        # Calculate interpolation factor within this segment
        segment_start_l = cumulative_lengths[current_segment_index]
        current_seg_len = segment_lengths[current_segment_index]

        if current_seg_len < 1e-9: # Avoid division by zero for zero-length segments
            interp_fraction = 0.0
        else:
            interp_fraction = (target_l - segment_start_l) / current_seg_len

        # Interpolate position
        p_start = original_nodes[current_segment_index]
        # Use the pre-calculated segment vector for direction
        segment_vec = segments[current_segment_index]
        new_nodes[i] = p_start + interp_fraction * segment_vec

    # Update knot object
    knot.nodes = new_nodes
    knot.num_nodes = target_n
    knot.update_length() # Recalculate L based on new points
    knot.target_leash_length = knot.length / knot.num_nodes if knot.num_nodes > 0 else 0

# Example usage (optional, for testing)
if __name__ == '__main__':
    coords = np.array([[0., 0., 0.], [1., 0., 0.], [1., 1., 0.], [0., 1., 0.]])
    knot = Knot(coordinates=coords, diameter=0.1)
    print("Initial:", knot)
    print("Initial leashes:", knot.get_leash_lengths())

    # Make leashes unequal
    knot.nodes[1] = [1.5, 0, 0]
    knot.nodes[2] = [1.5, 1.5, 0]
    print("\nModified:", knot)
    print("Modified leashes:", knot.get_leash_lengths())

    print("\nRunning control_leashes...")
    min_l, max_l = control_leashes(knot)
    print(f"After 1 pass: Min Leash={min_l:.4f}, Max Leash={max_l:.4f}")
    print("Knot state:", knot)
    print("Leashes:", knot.get_leash_lengths())

    print("\nRunning control_leashes 100 more times...")
    for _ in range(100):
        min_l, max_l = control_leashes(knot)

    print(f"After 101 passes: Min Leash={min_l:.4f}, Max Leash={max_l:.4f}")
    print("Knot state:", knot)
    print("Final leashes:", knot.get_leash_lengths())

    # Check total length conservation (should ideally be somewhat conserved by CL)
    knot.update_length()
    print("Final L (recalculated):", knot.length)

    print("\n" + "="*20 + "\n") # Separator

    # Example for find_neighbours
    coords = np.array([
        [0., 0., 0.], [1., 0., 0.], [2., 0., 0.], [3., 0., 0.], # Chain segment
        [1.5, 0.1, 0.] # Close node, but index distance depends on skipped
    ])
    num_nodes = coords.shape[0]
    diameter = 0.5
    knot = Knot(coordinates=coords, diameter=diameter)
    print("Neighbour Finding Example:")
    print(knot)
    print(f"Target Leash: {knot.target_leash_length:.3f}")
    print(f"Diameter: {knot.diameter}")

    skipped_test = 1 # Only immediate neighbours along chain are ignored
    epsilon_test = 0.01
    print(f"\nRunning find_neighbours with skipped={skipped_test}, epsilon={epsilon_test}")
    neighbours = find_neighbours(knot, skipped_test, epsilon_test)
    for i, node_neighbours in enumerate(neighbours):
        print(f"  Node {i}: Neighbours = {node_neighbours}")
    # Expected: Node 1 and 4 should be neighbours (dist ~0.5, index dist 3 > 1)
    # Node 0 and 4? dist ~1.5 > 0.5 + eps. No.
    # Node 2 and 4? dist ~1.5 > 0.5 + eps. No.
    # Node 3 and 4? dist ~1.5 > 0.5 + eps. No.

    skipped_test = 3 # Now node 4 is "close" index-wise to node 1 (dist=3)
    print(f"\nRunning find_neighbours with skipped={skipped_test}, epsilon={epsilon_test}")
    neighbours = find_neighbours(knot, skipped_test, epsilon_test)
    for i, node_neighbours in enumerate(neighbours):
        print(f"  Node {i}: Neighbours = {node_neighbours}")
    # Expected: No neighbours, because index distance 3 is not > 3.

    # Make node 4 much closer to node 0
    knot.nodes[4] = [0.1, 0.1, 0]
    print("\nMoved node 4 close to node 0")
    skipped_test = 1
    print(f"Running find_neighbours with skipped={skipped_test}, epsilon={epsilon_test}")
    neighbours = find_neighbours(knot, skipped_test, epsilon_test)
    for i, node_neighbours in enumerate(neighbours):
        print(f"  Node {i}: Neighbours = {node_neighbours}")
    # Expected: Node 0 and 4 should be neighbours (dist ~0.14, index dist 1 (wraparound) <= skipped=1). No.
    # Let's check the index dist calculation: n=5. i=0, k=4. |i-k|=4. n-|i-k|=1. min is 1. Correct.
    # Ah, the paper says "index distance is larger than a certain Skipped integer".
    # The check `if index_dist <= skipped:` is correct.
    # What if skipped = 0? Then 0 and 4 should be neighbours.
    skipped_test = 0
    print(f"Running find_neighbours with skipped={skipped_test}, epsilon={epsilon_test}")
    neighbours = find_neighbours(knot, skipped_test, epsilon_test)
    for i, node_neighbours in enumerate(neighbours):
        print(f"  Node {i}: Neighbours = {node_neighbours}")
     # Expected: Node 0 and 4 should be neighbours (dist ~0.14, index dist 1 > 0) 

    print("\n" + "="*20 + "\n") # Separator

    # Example for remove_overlaps
    coords = np.array([
        [0., 0., 0.], [1., 0., 0.], [2., 0., 0.], [3., 0., 0.],
        [1.5, 0.1, 0.], # Node 4, close to node 1
        [1.6, 0.15, 0.] # Node 5, close to node 4 and potentially node 1
    ])
    diameter = 0.5
    knot = Knot(coordinates=coords, diameter=diameter)
    print("Overlap Removal Example:")
    print(knot)

    skipped = 1
    epsilon = 0.1 # Need epsilon > 0 for find_neighbours to work correctly
    delta = 0.01 # Small positive delta

    print(f"\nRunning find_neighbours with skipped={skipped}, epsilon={epsilon}")
    neighbours = find_neighbours(knot, skipped, epsilon)
    for i, node_neighbours in enumerate(neighbours):
        print(f"  Node {i}: Initial Neighbours = {node_neighbours}")
    # Expected neighbours (dist^2 < (0.5+0.1)^2 = 0.36):
    # 1-4: vec=(-0.5, -0.1, 0), dist^2 = 0.25+0.01 = 0.26. YES. index dist=3 > 1.
    # 1-5: vec=(-0.6, -0.15, 0), dist^2 = 0.36+0.0225 = 0.3825. NO.
    # 4-5: vec=(-0.1, -0.05, 0), dist^2 = 0.01+0.0025 = 0.0125. YES. index dist=1 <= 1. NO.
    # Need to recheck index dist: N=6. (1,4) -> min(3, 6-3)=3 > 1. OK.
    # (4,5) -> min(1, 6-1)=1 <= 1. Correct, not neighbours.
    # What about 2-4? vec=(0.5, -0.1, 0), dist^2 = 0.25+0.01 = 0.26. YES. index dist=2 > 1.
    # What about 2-5? vec=(0.4, -0.15, 0), dist^2 = 0.16+0.0225 = 0.1825. YES. index dist=3 > 1.

    # Initial distances to check overlaps (diameter = 0.5)
    dist_1_4 = np.linalg.norm(knot.nodes[4] - knot.nodes[1]) # sqrt(0.26) ~= 0.51 > 0.5 (No overlap)
    dist_2_4 = np.linalg.norm(knot.nodes[4] - knot.nodes[2]) # sqrt(0.26) ~= 0.51 > 0.5 (No overlap)
    dist_2_5 = np.linalg.norm(knot.nodes[5] - knot.nodes[2]) # sqrt(0.1825) ~= 0.427 < 0.5 (Overlap!)

    # Let's force an overlap for testing
    print("\nForcing overlap between node 1 and 4")
    knot.nodes[4] = [1.1, 0.05, 0]
    dist_1_4 = np.linalg.norm(knot.nodes[4] - knot.nodes[1]) # sqrt(0.1^2 + 0.05^2) = sqrt(0.0125) ~= 0.11
    print(f"New distance 1-4: {dist_1_4:.3f}")
    neighbours = find_neighbours(knot, skipped, epsilon) # Re-run neighbour finding
    print("Re-running find_neighbours:")
    for i, node_neighbours in enumerate(neighbours):
        print(f"  Node {i}: Neighbours = {node_neighbours}")
    # Node 1 and 4 should definitely be neighbours now.

    print(f"\nRunning remove_overlaps with delta={delta}")
    max_ov, avg_ov = remove_overlaps(knot, neighbours, delta)
    print(f"Remove overlaps pass 1: Max Overlap={max_ov:.4f}, Avg Overlap={avg_ov:.4f}")
    # Check distances after removal
    dist_1_4_after = np.linalg.norm(knot.nodes[4] - knot.nodes[1])
    dist_2_5_after = np.linalg.norm(knot.nodes[5] - knot.nodes[2])
    target_dist = knot.diameter + delta
    print(f"Distance 1-4 after: {dist_1_4_after:.4f} (Target: {target_dist:.4f})")
    print(f"Distance 2-5 after: {dist_2_5_after:.4f} (Target: {target_dist:.4f})")

    print("\nRunning remove_overlaps again...")
    max_ov, avg_ov = remove_overlaps(knot, neighbours, delta)
    print(f"Remove overlaps pass 2: Max Overlap={max_ov:.4f}, Avg Overlap={avg_ov:.4f}")
    dist_1_4_after2 = np.linalg.norm(knot.nodes[4] - knot.nodes[1])
    dist_2_5_after2 = np.linalg.norm(knot.nodes[5] - knot.nodes[2])
    print(f"Distance 1-4 after 2: {dist_1_4_after2:.4f}")
    print(f"Distance 2-5 after 2: {dist_2_5_after2:.4f}")

    print("\n" + "="*20 + "\n") # Separator

    # Example for shift_nodes
    coords = np.array([
        [0., 0., 0.], [1., 0., 0.], [1., 1., 0.], [0., 1., 0.]
    ])
    knot = Knot(coordinates=coords, diameter=0.1)
    print("Shift Nodes Example:")
    print("Initial knot:", knot)
    print("Initial nodes:\n", knot.nodes)

    shift_frac = 0.1
    print(f"\nRunning shift_nodes with shift_fraction={shift_frac}")
    shift_nodes(knot, shift_frac)
    print("Knot after shift:", knot)
    print("Nodes after shift:\n", knot.nodes)

    # Verify shift calculation for node 0 (assuming direction was +1, forward)
    # P0 = [0,0,0], P1 = [1,0,0]. Vec = P1-P0 = [1,0,0]
    # New P0 = [0,0,0] + 0.1 * [1,0,0] = [0.1, 0, 0]
    # (If direction was -1, backward towards P3=[0,1,0])
    # P0 = [0,0,0], P3 = [0,1,0]. Vec = P3-P0 = [0,1,0]
    # New P0 = [0,0,0] + 0.1 * [0,1,0] = [0, 0.1, 0]
    print("\nNote: Shift direction is random (+1 forward, -1 backward)")

    print("\n" + "="*20 + "\n") # Separator

    # Example for node number manipulation
    coords = np.array([
        [0., 0., 0.], [1., 0., 0.], [1., 1., 0.], [0., 1., 0.], # N=4
        [-1., 1., 0.], [-1., 0., 0.] # N=6
    ])
    knot = Knot(coordinates=coords, diameter=0.1)
    print("Node Number Manipulation Example:")
    print("Initial knot:", knot)

    print("\nDoubling node number...")
    double_node_number(knot)
    print("After doubling:", knot)
    print(f"Leash lengths: {knot.get_leash_lengths()}")

    print("\nDoubling node number again...")
    double_node_number(knot)
    print("After second doubling:", knot)

    print("\nReducing node number...")
    reduce_node_number(knot)
    print("After reducing:", knot)
    print(f"Leash lengths: {knot.get_leash_lengths()}")

    print("\nReducing node number again...")
    reduce_node_number(knot)
    print("After second reducing:", knot)
    print(f"Leash lengths: {knot.get_leash_lengths()}")

    print("\n" + "="*20 + "\n") # Separator

    # Example for normalize_node_number
    coords = np.array([
       [0., 0., 0.], [1., 0., 0.], [1., 1., 0.], [0., 1., 0.] # Square, L=4
    ])
    diameter = 0.2
    knot = Knot(coordinates=coords, diameter=diameter)
    print("Node Normalization Example:")
    print("Initial knot:", knot) # N=4, L=4, D=0.2 -> L/D = 20

    target_dens = 10.0
    expected_n = round(target_dens * knot.length / knot.diameter)
    print(f"\nNormalizing with target density {target_dens}...")
    print(f"Expected N = round({target_dens} * {knot.length:.1f} / {knot.diameter}) = {expected_n}")
    normalize_node_number(knot, target_density=target_dens)
    print("After normalization:", knot)
    print(f"Leash lengths: {knot.get_leash_lengths()}") # Should be fairly uniform

    # Example with different L/D
    coords_long = np.array([
       [0., 0., 0.], [5., 0., 0.], [5.1, 10., 0.], [0.1, 10., 0.] # Approx L= Sqrt(25)+10+Sqrt(25)+10 = 30
    ])
    knot_long = Knot(coordinates=coords_long, diameter=0.5)
    print("\nLong knot example:")
    print(f"Initial knot: {knot_long}") # N=4, L~30.2, D=0.5 -> L/D ~ 60.4
    expected_n = round(target_dens * knot_long.length / knot_long.diameter)
    print(f"Expected N = round({target_dens} * {knot_long.length:.1f} / {knot_long.diameter}) = {expected_n}")
    normalize_node_number(knot_long, target_density=target_dens)
    print("After normalization:", knot_long)
    print(f"Leash lengths: {knot_long.get_leash_lengths()}") # Should be fairly uniform 